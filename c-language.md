# 第一个C语言程序  

```C
#include <stdio.h>
int main(int argc, char* argv[]){
  printf("Hello world~\n");
  return 0;
}
```

----

# 基本语法  

## 分号;  

在 C 程序中，**分号**是语句结束符。也就是说，每个语句必须以**分号**结束。它表明一个逻辑实体的结束。

以下是两个不同的语句：  

```C
printf("Hello world~\n");
return 0;
```

## 注释  

C 语言有两种注释方式：  

1. 以`//`开始的单行注释，从`//`开始独占一行的注释

```C
// 单行注释
```

2. 以`/*`开始以`*/`结束的单行或多行注释

```C
/* 单行注释 */
/* 
 * 多行注释
 * 多行注释
*/
```

## 标识符  

C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 

C 标识符内不允许出现标点字符，比如 `@`、`$` 和`%`。C 是**区分大小写**的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。   

## 关键字   

C 中系统使用的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。   

## 空格   

只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。为了增强可读性，您可以根据需要适当增加一些空格。   

----

# 数据类型   

## 基本数据类型   

### 整数类型   

|      类型      | 存储大小 |          值范围           |
| :------------- | :------- | :------------------------ |
| char           | 1 B      | [-128, 127] or [0, 255]   |
| unsigned char  | 1 B      | [0, 255]                  |
| signed char    | 1 B      | [-128, 127]               |
| int            | 4 B      | [-2147483648, 2147483647] |
| unsigned int   | 4 B      | [0, 4294967295]           |
| short          | 2 B      | [-32768, 32767]           |
| unsigned short | 2 B      | [0, 65535]                |
| long           | 4 B      | [-2147483648, 2147483647] |
| unsigned long  | 4 B      | [0, 4294967295]           |

### 浮点类型

|  类型  | 存储大小 |        值范围        | 精度 |
| :----- | :------- | :------------------- | :--- |
| float  | 4 B      | [1.2E-38, 3.4E+38]   | 6    |
| double | 8 B      | [2.3E-308, 1.7E+308] | 15   |

## 变量

变量是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

```C
type variable_list;
```

`type`是**有效的数据类型**，`variable_list`是一个或多个**变量名字**，多个变量名字用`,`隔开，例如：

```C
int a;
char c, ch;
```

## 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

在 C 中，有简单的定义常量的方式：

```C
const type variable = value;
```

必须在定义变量的时候进行初始化


## 运算符

### 赋值运算符

`=`，二元运算符，把右边的值赋值给左边

### 算术运算符

1. `+`，二元运算符，加法 
2. `-`，二元运算符，减法，一元前缀运算符，取相反数
3. `*`，二元运算符，乘法
4. `/`，二元运算符，除法
5. `%`，二元运算符，取模
6. `#=`，二元运算符，先进行`#`计算*（`#`为任意二元运算符）*，再把计算结果赋值给左边的变量，例如：  `i += 5;  // i = i + 5;`
7. `++`，一元运算符，自增符号，有前缀和后缀用法
8. `--`，一元运算符，自减符号，有前缀和后缀用法

### 关系运算符  

1. `==`，二元运算符
2. `!=`，二元运算符
3. `>`，二元运算符
4. `<`，二元运算符
5. `>=`，二元运算符
6. `<=`，二元运算符

### 逻辑运算符  

1. `&&`，二元运算符，与
2. `||`，二元运算符，或
3. `!`，一元前缀运算符，非

### 位运算符

5. `<<`，二元运算符，左移，相当于乘2的幂次方
6. `>>`，二元运算符，右移，相当于除2的幂次方

### 其他运算符

1. `?:`，唯一三元运算符，`A?B:C`若A不为0则返回B，否则返回C
2. `&`，一元运算符，返回变量的地址
3. `*`，一元运算符，`&`的逆运算

## 类型转换

### 隐式类型转换

隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。

```C
int i = 10;
float f = 3.14;
double d = i + f;  // 自动将int类型转为double，但i和f的实际类型并未改变
```

### 显式类型转换

显式类型转换需要使用强制类型转换运算符，它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。

```C
double d = 3.14;
int i = (int)d;  // 强制将double类型转为int，但d的实际类型并未改变
```

## 输入和输出

### scanf() 和 printf() 函数

1. `int scanf(const char *format, ...)`
    **附加参数** -- 根据不同的 **format 字符串**，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 `%` 标签。参数的个数应与 `%` 标签的个数相同。

```C
scanf("%d%d%d", &a, &b, &c);
```

  1. `&a`、`&b`、`&c` 中的 `&` 是地址运算符，分别获得这三个变量的内存地址。
  2. `%d%d%d` 是按十进值格式输入三个数值。输入时，在两个数据之间可以用一个或多个空格、tab 键、回车键分隔。如果使用**字符**来分隔输入的 `%d`，相应的输入时也需要添加相应的**字符**。

2. `int printf(const char *format, ...)`
    **附加参数** -- 根据不同的 **format 字符串**，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 `%` 标签。参数的个数应与 `%` 标签的个数相同。

```C
printf("%d%d%d\n", a, b, c);
```

### getchar() 和 putchar() 函数

1. `int getchar(void)`

```C
c = getchar();  // 捕获从键盘上输入一个字符赋值给c
```

2. `int putchar(int char)`

```C
c = 'a';
putchar(c);  // 显示器输出一个字符c
```

> 编写一个程序，要求用户输入两个整数，并输出它们的和、差、积、商和余数。   
> 编写一个程序，要求用户输入一个整数 n，然后输入 n 个整数，并输出这 n 个整数的平均值。

----

# 控制结构

## 判断

### 二分判断

1. `if`语句

```C
if (a < 0) {
  a = -a;
}
```

2. `if else`语句

```C
if (a < 0) {
  a = -a;
} else {
  a += 1;
}
```

3. `else if`语句

```C
if (a < 0) {
  a = 0;
} else if (a > 0) {
  a = 0;
}
```

### 多分判断

`switch`语句

```C
char c = getchar();
switch (c) {
  case 'a': // c == 'a'
    printf("a"); break;
  case 'b': 
    printf("b"); break;
  default:  // 默认
    printf("None");
}
```

## 循环

1. `for`循环

```C
(起始标志; 循环条件; 起始标志的迭代)
for (int i = 0; i < n; i += 1) {
  printf("%d", i);
}
```

2. `while`循环

```C
int i = 0;
while (i < n) {
  printf("%d", i);
  i += 1;
}
```

```C
int i = 0;
do {
  printf("%d", i);
  i += 1;
} while (i < n);
```

- `continue`: 停止当前循环立即进入下一轮循环
- `break`: 结束当前循环体

> 编写一个程序，要求用户输入一个整数，并输出它的阶乘。   
> 编写一个程序，要求用户输入一个年份，并输出该年是否为闰年。   
> 编写一个程序，要求用户输入一个整数，判断它是否为质数。   
> 编写一个程序，要求用户输入一个整数 n，输出所有小于 n 的质数。   

----

# 函数   

函数是一组一起执行一个任务的语句   

## 函数定义   

```C
int a = 0;
return_type function_name(parameter list){
  body of function;
}
```

- 返回类型：一个函数可以返回一个值。return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。   
- 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。   
- 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。**参数是可选的**，也就是说，函数可能不包含参数。   
- 函数主体：函数主体包含一组定义函数执行任务的语句。   

## 函数声明   


函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。   

```C
return_type function_name(parameter list);
```

例如：   

```C
int a; // 声明
int max(int num1, int num2);
```

或者   

```C
int max(int, int);
```

## 局部变量和全局变量   

1. 局部变量   
    在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。   

2. 全局变量   
    全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。   

3. 形式参数   
    形式参数是函数的参数，被当作该函数内的局部变量，如果与**全局变量**同名它们会**优先使用**。   

## 值传递   

向函数传递参数的**传值调用**方法，把参数的实际值**拷贝**给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。   

默认情况下，C 语言使用**传值调用**方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。   

```C
#include <stdio.h>

void swap(int x, int y){
  x += y;
  y -= x;
  y = -y;
  x -= y;
  return;
}

int main(int argc, char* argv[]){
  int a = 1, b = 2;
  printf("Before: a = %d, b = %d\n", a, b);
  swap(a, b);
  printf("After: a = %d, b = %d\n", a, b);
  return 0;
}
```

## 址传递    

通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。   

```C
 <stdio.h>

void swap(int* x, int* y){
  (*x) += (*y);
  (*y) -= (*x);
  (*y) = -(*y);
  (*x) -= (*y);
  return;
}

int main(int argc, char* argv[]){
  int a = 1, b = 2;
  printf("Before: a = %d, b = %d\n", a, b);
  swap(&a, &b);
  printf("After: a = %d, b = %d\n", a, b");
  return 0;
}
```

> 编写一个函数，求一个整数的阶乘。  
> 编写一个函数，求一个整数数组的平均值。  
> 编写一个函数，求一个年份是否为闰年。  
> 编写一个函数，求一个整数是否为质数。  

----

# 数组   

数组是一个**存储固定**大小的**相同类型元素**的**顺序集合**。   

## 数组声明    

```C
type array_name[array_size];
```

这是一维数组。array_size 必须是一个**大于零的整数常量**，type 可以是任意有效的 C 数据类型。    

## 数组初始化   

可以逐个初始化数组，也可以使用一个初始化语句   

```C
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 `{ }` 之间的值的数目不能大于我们在数组声明时在方括号 `[ ]` 中指定的元素数目。   
如果您省略掉了数组的大小，数组的大小则为初始化时**元素的个数**。   

```C
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

## 访问数组元素   

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。   

```C
double salary = balance[9];
```

所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。   

## 数组的类型   

```C
type array_name[array_size];
```

对array_name数组而言，array_name也是一个变量，类型为`type [array_size]`，例如：   

```C
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

balance就是一个变量，其类型为`double [5]`   

## 二维数组   

多维数组声明的一般形式如下：   

```C
type name[size1][size2]...[sizeN];
```

### 初始化二维数组   

可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组：   

```C
int a[3][4] = {  
 {0, 1, 2, 3},    /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7},    /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

```java
public class Hello {
  public static void main(String[] arg) {
    System.out.println("Hello World");
  }
}
```

a是一个一维数组，其类型为`int [3][4]`，a的元素分别是a[0]、a[1]、a[2]；   

a[0]也是一个一维数组，其类型为`int [4]`，a[0]的元素分别是a[0][0]、a[0][1]、a[0][2]、a[0][3]


## 字符串   

> 当作一种类型看待
> a, b; 希望a和b能使用加法、赋值、比较 ==
char string[80]就是一个字符型数组，常用名称为字符串，以下是在头文件`string.h`中定义的常用函数：    

- `char* strcat(char* dest, const char* src)`，把src字符串追加到dest字符串的结尾   
- `int strcmp(const char* str1, const char* str2)`，比较str1和str2   
- `char* strcpy(char* dest, const char* src)`，把src字符串复制给dest    
- `int strlen(const char* str)`，计算字符串str长度，直到`\0`为止，但不包括   
- `char* strstr(const char *haystack, const char *needle)`，在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 `\0`。该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null   

> 编写一个程序，要求用户输入一个整数 n，然后输入 n 个整数，将它们存入一个数组，并输出数组中的最大值和最小值。   
> 编写一个程序，要求用户输入一个整数 n，然后输入 n 个整数，将它们存入一个数组，并输出其中的所有偶数。   
> 编写一个程序，要求用户输入一个整数 n，然后输入 n 个字符串，将它们存入一个二维数组，并输出其中长度最长的字符串。    
> 编写一个程序，要求用户输入一个整数 n，然后输入 n 个整数，将它们存入一个数组，并按照从小到大的顺序排序。   
> 编写一个函数，接受一个整数数组和数组的长度作为参数，将数组中的元素按照从小到大的顺序排序。   


----

# 指针   

指针也就是内存地址，指针变量是用来存放内存地址的**变量**   

每一个变量都有一个内存位置，每一个内存位置都定义了可使用 `&` 运算符访问的地址，它表示了在内存中的一个地址   

## 指针变量声明   

指针变量声明的一般形式为：

```C
type* var_name;
```

指针的基类型是`type` ，它必须是一个有效的 C 数据类型，指针变量的名称是`var_name` ，指针变量的类型`type*`   

> 注意：`type *var_name`，`type* var_name`，`type * var_name`写法完全等同   
> 但`int* a, b`中，a是指针变量，b是整数变量，连续定义指针变量必须写为`int *a, *b`   

## NULL指针   

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。    

NULL 指针是一个定义在标准库中的值为零的常量。   

## 二级指针   

指向指针的指针是一种多级间接寻址的形式   

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：   

```C
int a = 10;
int* p = &a;
int** q = &p;
```

此时，`a`<-->`*p`<-->`**q`，`&a`<-->`p`<-->`*q`   


## 指针与函数   

### 指针作为形参    

```C
 <stdio.h>

void func1(int x){
  x = 0;
}
void func2(int* x){
  *x = 0;
}

int main(int argc, char* argv[]){
  int a = 5;
  printf("Befor: a = %d\n", a);
  
  func1(a);
  printf("By func1: a = %d\n", a);
  int* p = &a;
  func2(p);
  printf("By func2: a = %d\n", a);
  
  return 0;
}
```

### 从函数返回指针   

```C
int func3(int x);
int* func4(int x);
```

### 指向函数的指针   

函数名包含了函数所在的地址，可以用指针记录函数所在地址   

```C
int func(int, int);
int (*p)(int, int) = func;
```

此时，`func(a,b)`<-->`(*p)(a,b)`   

## 指针与数组   

### 指针数组   

```C
int a[10];
int* p[10];
```

### 数组地址   

数组名包含了数组所在地址，能接受指针作为参数的函数，也能接受数组作为参数    

```C
int func2(int*);
int a[5] = {1, 2, 3, 4, 5};
func2(a);
```

### 指针的算术运算   

指针仅支持加减运算，包括`+`、`-`、`++`、`--`    

```C
int a[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i += 1) {
  scanf("%d", a + i);
  printf("a[%d] = %d\n", i, *(a+i));
}
```

> 编写一个函数，接受两个整数指针作为参数，交换它们指向的值。    
> 编写一个函数，接受一个整数指针作为参数，将它指向的整数加1。    
> 编写一个函数，接受一个字符串作为参数，将它反转并返回反转后的字符串。   


----

# 结构体

C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。

## 定义结构

结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。

struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
```C
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list;
```
tag 是结构体标签。  
member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。  
variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。

下面是声明 Book 结构的方式：  
```C
struct Books {
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。

## 结构体变量的初始化

和其它类型变量一样，对结构体变量可以在定义时指定初始值。

## 访问结构成员

为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。

## 指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似


## 番外：共用体

共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

### 定义共用体
为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：
```C
union [union tag] {
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
```
union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：
```C
union Data {
   int i;
   float f;
   char str[20];
} data;
```
现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。
共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：
```C
#include <stdio.h>
#include <string.h>
 
union Data {
   int i;
   float f;
   char str[20];
};
 
int main() {
   union Data data;        
   printf("Memory size occupied by data : %d\n", sizeof(data));
   return 0;
}
```

### 访问共用体成员

为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

```C
#include <stdio.h>
#include <string.h>
 
union Data {
   int i;
   float f;
   char  str[20];
};
 
int main( ) {
   union Data data;        
 
   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");
 
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
```


## 番外：枚举

枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。，它可以让数据更简洁，更易读。
枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。
定义一个枚举类型，需要使用 `enum` 关键字，后面跟着枚举类型的名称，以及用大括号 `{}` 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。
枚举语法定义格式为：
```C
enum　枚举名　{枚举元素1,枚举元素2,……};
```
接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：
```C
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
```
这个看起来代码量就比较多，接下来我们看看使用枚举的方式：
```
enum DAY {
    MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```
这样看起来是不是更简洁了。  
注意：第一个枚举成员的默认值为整型的 **0**，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

可以在定义枚举类型时改变枚举元素的值：
```C
enum season {spring, summer=3, autumn, winter};
```
没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

### 枚举变量的定义

前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。
我们可以通过以下三种方式来定义枚举变量

1、先定义枚举类型，再定义枚举变量
```C
enum DAY {
    MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```
2、定义枚举类型的同时定义枚举变量
```C
enum DAY {
    MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```
3、省略枚举名称，直接定义枚举变量
```C
enum {
    MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```


----



----

# 文件读写

## 打开文件

使用 `fopen()` 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 `FILE` 的一个对象，类型 `FILE` 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：
```C
FILE *fopen(const char *filename, const char *mode );
```
在这里，`filename` 是字符串，用来命名文件，访问模式 `mode` 的值可以是下列值中的一个：
| 模式 | 描述 |
| --- | --- |
| r |	打开一个已有的文本文件，允许读取文件。 |
| w	| 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a |	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+ | 打开一个文本文件，允许读写文件。 |
| w+ | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |
| a+ | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

## 关闭文件

为了关闭文件，请使用 `fclose()` 函数。函数的原型如下：
```C
int fclose(FILE *fp);
```
如果成功关闭文件，`fclose()` 函数返回零，如果关闭文件时发生错误，函数返回 `EOF`。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。`EOF` 是一个定义在头文件 `stdio.h` 中的常量。

## 读写文件


